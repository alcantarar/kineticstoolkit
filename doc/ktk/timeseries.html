<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>ktk.timeseries API documentation</title>
<meta name="description" content="Module that provides the TimeSeries and TimeSeriesEvent classes. The classes
defined in this module are loaded into the toplevel ktk namespace." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ktk.timeseries</code></h1>
</header>
<section id="section-intro">
<p>Module that provides the TimeSeries and TimeSeriesEvent classes. The classes
defined in this module are loaded into the toplevel ktk namespace.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ktk.timeseries.dataframe_to_dict_of_arrays"><code class="name flex">
<span>def <span class="ident">dataframe_to_dict_of_arrays</span></span>(<span>dataframe)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert a pandas DataFrame to a dict of numpy ndarrays.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pd_dataframe</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The dataframe to be converted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dict of ndarrays.</p>
<dl>
<dt><code>If</code> <code>all</code> <code>the</code> <code>dataframe</code> <code>columns</code> <code>have</code> <code>the</code> <code>same</code> <code>name</code> <code>but</code> <code>with</code> <code>different</code> <code>indices</code></dt>
<dd>&nbsp;</dd>
<dt><code>in</code> <code>brackets</code>, <code>then</code> <code>the</code> <code>dataframe</code> <code>corresponds</code> <code>to</code> <code>a</code> <code>single</code> <code>array</code>, <code>which</code> <code>is</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>returned.</p>
<dl>
<dt><code>If</code> <code>the</code> <code>dataframe</code> <code>contains</code> <code>different</code> <code>column</code> <code>names</code> (<code>for</code> <code>example</code>,</dt>
<dd>&nbsp;</dd>
<dt><code>Forces</code>[<code>0</code>], <code>Forces</code>[<code>1</code>], <code>Forces</code>[<code>2</code>], <code>Moments</code>[<code>0</code>], <code>Moments</code>[<code>1</code>], <code>Moments</code>[<code>2</code>]), <code>then</code></dt>
<dd>&nbsp;</dd>
<dt><code>a</code> <code>dict</code> of <code>arrays</code> <code>is</code> <code>returned.</code> <code>In</code> <code>this</code> <code>case</code>, <code>this</code> <code>dict</code> <code>would</code> <code>have</code> <code>the</code> <code>keys</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>'Forces' and 'Moments', which would each contain an array.</p>
<dl>
<dt><code>This</code> <code>function</code> <code>mirrors</code> <code>the</code> <a title="ktk.timeseries.dict_of_arrays_to_dataframe" href="#ktk.timeseries.dict_of_arrays_to_dataframe"><code>dict_of_arrays_to_dataframe()</code></a> <code>function.</code> <code>Its</code> <code>use</code> <code>is</code></dt>
<dd>&nbsp;</dd>
<dt><code>mainly</code> <code>to</code> <code>convert</code> <code>high</code>-<code>dimension</code> (&gt;<code>2</code>) <code>dataframes</code> <code>to</code> <code>high</code>-<code>dimension</code> (&gt;<code>2</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<p>arrays.</p></section>
</dd>
<dt id="ktk.timeseries.dict_of_arrays_to_dataframe"><code class="name flex">
<span>def <span class="ident">dict_of_arrays_to_dataframe</span></span>(<span>dict_of_arrays)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert a numpy ndarray of any dimension to a pandas DataFrame.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dict_of_array</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dict that contains numpy arrays. Each array must have the same
first dimension's size.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><code>The</code> <code>rows</code> <code>in</code> <code>the</code> <code>output</code> <code>DataFrame</code> <code>correspond</code> <code>to</code> <code>the</code> <code>first</code> <code>dimension</code> of <code>the</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>numpy arrays.
- Vectors are converted to single-column DataFrames.
- 2-dimensional arrays are converted to multi-columns DataFrames.
- 3-dimensional (or more) arrays are also converted to DataFrames, but
indices in brackets are added to the column names.</p></section>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ktk.timeseries.TimeSeries"><code class="flex name class">
<span>class <span class="ident">TimeSeries</span></span>
<span>(</span><span>time=array([], dtype=float64), time_info={'Unit': 's'}, data={}, data_info={}, events=[], from_dataframe=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A class that implements TimeSeries.</p>
<p>This class implements a Timeseries in a way that resembles the timeseries
and tscollection found in Matlab.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>1</code>-<code>dimension</code> <code>np.array</code> (optional)</dt>
<dd>Contains the time vector. The default is [].</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code> (optional)</dt>
<dd>Contains the data, where each element contains a np.array which
first dimension corresponds to time. The default is {}.</dd>
<dt><strong><code>time_info</code></strong> :&ensp;<code>dict</code> (optional)</dt>
<dd>Contains metadata relative to time. The default is {'Unit': 's'}</dd>
<dt><strong><code>data_info</code></strong> :&ensp;<code>dict</code> (optional)</dt>
<dd>
<p>Contains facultative metadata relative to data. For example, the
data_info attribute could indicate the unit of data['Forces']:</p>
<p>data['Forces'] = {'Unit': 'N'}.</p>
<p>To facilitate the management of data_info, please use
<code>ktk.TimeSeries.add_data_info</code>.</p>
<p>The default is {}.</p>
</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.arange(0,100))
</code></pre></section>
<h3>Methods</h3>
<dl>
<dt id="ktk.timeseries.TimeSeries.add_data_info"><code class="name flex">
<span>def <span class="ident">add_data_info</span></span>(<span>self, data_key, info_key, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Add metadata to TimeSeries' data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_key</code></strong> :&ensp;<code>str</code></dt>
<dd>The data key the info corresponds to.</dd>
<dt><strong><code>info_key</code></strong> :&ensp;<code>str</code></dt>
<dd>The key of the info dict.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>any</code> <code>type</code></dt>
<dd>The info.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; ts = ktk.TimeSeries()
&gt;&gt;&gt; ts.add_data_info('Forces', 'Unit', 'N')
&gt;&gt;&gt; ts.add_data_info('Marker1', 'Color', [43, 2, 255])

&gt;&gt;&gt; ts.data_info['Forces']
{'Unit': 'N'}

&gt;&gt;&gt; ts.data_info['Marker1']
{'Color': [43, 2, 255]}
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.add_event"><code class="name flex">
<span>def <span class="ident">add_event</span></span>(<span>self, time, name='event')</span>
</code></dt>
<dd>
<section class="desc"><p>Add an event to the TimeSeries.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code></dt>
<dd>The time of the event, in the same unit as <code>time_info['Unit']</code>
(default: 's').</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code> (optional)</dt>
<dd>The name of the event.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; ts = ktk.TimeSeries()
&gt;&gt;&gt; ts.add_event(5.5, 'event1')
&gt;&gt;&gt; ts.add_event(10.8, 'event2')
&gt;&gt;&gt; ts.add_event(2.3, 'event2')

&gt;&gt;&gt; ts.events
[[5.5, 'event1'], [10.8, 'event2'], [2.3, 'event2']]
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Deep copy of a TimeSeries.</p>
<h2 id="returns">Returns</h2>
<p>A deep copy of the original TimeSeries.</p></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.fill_missing_samples"><code class="name flex">
<span>def <span class="ident">fill_missing_samples</span></span>(<span>self, max_missing_samples, *, method='linear')</span>
</code></dt>
<dd>
<section class="desc"><p>Fill missing samples with the given method.</p>
<p>This function is experimental and its signature and default values
may change in future.</p>
<p>The sample rate must be constant.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>max_missing_samples</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximal number of consecutive missing samples to fill. Set to
zero to fill all missing samples.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code> (optional)</dt>
<dd>The interpolation method. This input may take any value
supported by scipy.interpolate.interp1d, such as:
- 'linear'
- 'nearest'
- 'zero'
- 'slinear'
- 'quadratic'
- 'cubic'
- 'previous'
- 'next'</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.from_dataframe"><code class="name flex">
<span>def <span class="ident">from_dataframe</span></span>(<span>self, dataframe)</span>
</code></dt>
<dd>
<section class="desc"><p>Load time and data from a DataFrame.</p>
<p>The current TimeSeries' time and data properties are overwritten.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dataframe</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>
<p>A Pandas DataFrame where the index corresponds to time, and
where each column corresponds to a data key. As special cases,
data in column which names end with bracketed indices such as
[0], [1], [0,0], [0,1], etc. are converted to multidimensional
arrays. For example, if a DataFrame has these column names:</p>
<pre><code>Forces[0], Forces[1], Forces[2], Forces[3]
</code></pre>
<p>then a single data key is created (Forces) and the data itself
will be of shape Nx4, N being the number of samples (the length
of the DataFrame).</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>self.</p></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_event_time"><code class="name flex">
<span>def <span class="ident">get_event_time</span></span>(<span>self, event_name, event_occurrence=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the time of the specified event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the event to look for in the events list.</dd>
<dt><strong><code>event_occurrence</code></strong> :&ensp;<code>int</code> (optional)</dt>
<dd>i_th occurence of the event to look for in the events list,
starting at 0. The default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>event_time</code></strong> :&ensp;<code>float</code></dt>
<dd>The time of the specified event, as a float. If no corresponding
event is found, then np.nan is returned.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; # Instanciate a timeseries with some events
&gt;&gt;&gt; ts = ktk.TimeSeries()
&gt;&gt;&gt; ts.add_event(5.5, 'event1')
&gt;&gt;&gt; ts.add_event(10.8, 'event2')
&gt;&gt;&gt; ts.add_event(2.3, 'event2')

&gt;&gt;&gt; ts.get_event_time('event1')
5.5

&gt;&gt;&gt; ts.get_event_time('event2', 0)
2.3

&gt;&gt;&gt; ts.get_event_time('event2', 1)
10.8
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_index_after_time"><code class="name flex">
<span>def <span class="ident">get_index_after_time</span></span>(<span>self, time, *, inclusive=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the time index that is just after the specified time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code></dt>
<dd>Time to look for in the TimeSeries' time vector.</dd>
<dt><strong><code>inclusive</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to include the given time in the comparison. The default is
False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>The index in the time vector. If no value is after the
specified time, a value of np.nan is returned.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.array([0, 0.5, 1, 1.5, 2]))

&gt;&gt;&gt; ts.get_index_after_time(0.9)
2

&gt;&gt;&gt; ts.get_index_after_time(1)
3

&gt;&gt;&gt; ts.get_index_after_time(1, inclusive=True)
2

&gt;&gt;&gt; ts.get_index_after_time(1.1)
3

&gt;&gt;&gt; ts.get_index_after_time(13)
nan
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_index_at_time"><code class="name flex">
<span>def <span class="ident">get_index_at_time</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the time index that is the closest to the specified time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code></dt>
<dd>Time to look for in the TimeSeries' time vector.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>The index in the time vector.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.array([0, 0.5, 1, 1.5, 2]))

&gt;&gt;&gt; ts.get_index_at_time(0.9)
2

&gt;&gt;&gt; ts.get_index_at_time(1)
2

&gt;&gt;&gt; ts.get_index_at_time(1.1)
2
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_index_before_time"><code class="name flex">
<span>def <span class="ident">get_index_before_time</span></span>(<span>self, time, *, inclusive=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the time index that is just before the specified time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code></dt>
<dd>Time to look for in the TimeSeries' time vector.</dd>
<dt><strong><code>inclusive</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to include the given time in the comparison. The default is
False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>The index in the time vector. If no value is before the specified
time, a value of np.nan is returned.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import ktk
&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.array([0, 0.5, 1, 1.5, 2]))

&gt;&gt;&gt; ts.get_index_before_time(0.9)
1

&gt;&gt;&gt; ts.get_index_before_time(1)
1

&gt;&gt;&gt; ts.get_index_before_time(1, inclusive=True)
2

&gt;&gt;&gt; ts.get_index_before_time(1.1)
2

&gt;&gt;&gt; ts.get_index_before_time(-1)
nan
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_subset"><code class="name flex">
<span>def <span class="ident">get_subset</span></span>(<span>self, data_keys)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a subset of the TimeSeries.</p>
<p>This method returns a TimeSeries that contains only selected data
keys. The corresponding data_info keys are copied in the new
TimeSeries. All events are also copied in the new TimeSeries.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_keys</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>The data keys to extract from the timeseries.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a></dt>
<dd>A copy of the TimeSeries, minus the unspecified data keys.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; ts = ktk.TimeSeries(time = np.arange(10))
&gt;&gt;&gt; ts.data['signal1'] = ts.time
&gt;&gt;&gt; ts.data['signal2'] = ts.time**2
&gt;&gt;&gt; ts.data['signal3'] = ts.time**3
&gt;&gt;&gt; ts.data.keys()
dict_keys(['signal1', 'signal2', 'signal3'])

&gt;&gt;&gt; ts2 = ts.get_subset(['signal1', 'signal3'])
&gt;&gt;&gt; ts2.data.keys()
dict_keys(['signal1', 'signal3'])
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_ts_after_event"><code class="name flex">
<span>def <span class="ident">get_ts_after_event</span></span>(<span>self, event_name, event_occurrence=0, *, inclusive=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a subset of the TimeSeries after the specified event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the event to look for in the events list.</dd>
<dt><strong><code>event_occurrence</code></strong> :&ensp;<code>int</code> (optional)</dt>
<dd>i_th occurence of the event to look for in the events list,
starting at 0. The default is 0.</dd>
<dt><strong><code>inclusive</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to include the given event in the comparison. The default is
False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a></dt>
<dd>A new TimeSeries following the specification.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import ktk
&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.arange(10)/10)
&gt;&gt;&gt; ts.add_event(0.2, 'event')
&gt;&gt;&gt; ts.add_event(0.35, 'event')
&gt;&gt;&gt; ts.time
array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

&gt;&gt;&gt; ts.get_ts_after_event('event').time
array([0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

&gt;&gt;&gt; ts.get_ts_after_event('event', inclusive=True).time
array([0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

&gt;&gt;&gt; ts.get_ts_after_event('event', 1).time
array([0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

&gt;&gt;&gt; ts.get_ts_after_event('event', 1, inclusive=True).time
array([0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_ts_after_index"><code class="name flex">
<span>def <span class="ident">get_ts_after_index</span></span>(<span>self, index, *, inclusive=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a subset of the TimeSeries after the specified time index.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>Time index</dd>
<dt><strong><code>inclusive</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to include the given time index. The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a></dt>
<dd>A new TimeSeries following the specification.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import ktk
&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.arange(10)/10)
&gt;&gt;&gt; ts.time
array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

&gt;&gt;&gt; ts.get_ts_after_index(2).time
array([0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

&gt;&gt;&gt; ts.get_ts_after_index(2, inclusive=True).time
array([0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_ts_after_time"><code class="name flex">
<span>def <span class="ident">get_ts_after_time</span></span>(<span>self, time, *, inclusive=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a subset of the TimeSeries after the specified time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code></dt>
<dd>Time to look for in the TimeSeries' time vector.</dd>
<dt><strong><code>inclusive</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to include the given time in the comparison. The default is
False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a></dt>
<dd>A new TimeSeries following the specification.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import ktk
&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.arange(10)/10)
&gt;&gt;&gt; ts.time
array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

&gt;&gt;&gt; ts.get_ts_after_time(0.3).time
array([0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

&gt;&gt;&gt; ts.get_ts_after_time(0.3, inclusive=True).time
array([0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_ts_at_event"><code class="name flex">
<span>def <span class="ident">get_ts_at_event</span></span>(<span>self, event_name, event_occurrence=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a one-data subset of the TimeSeries at the event's nearest time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the event to look for in the events list.</dd>
<dt><strong><code>event_occurrence</code></strong> :&ensp;<code>int</code> (optional)</dt>
<dd>i_th occurence of the event to look for in the events list,
starting at 0. The default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a></dt>
<dd>A TimeSeries of length 1, at the event's nearest time.</dd>
</dl></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_ts_at_time"><code class="name flex">
<span>def <span class="ident">get_ts_at_time</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a one-data subset of the TimeSeries at the nearest time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code></dt>
<dd>Time to look for in the TimeSeries' time vector.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a></dt>
<dd>A TimeSeries of length 1, at the time neasest to the specified
time.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import ktk
&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.array([0, 0.5, 1, 1.5, 2]))
&gt;&gt;&gt; ts.time
array([0. , 0.5, 1. , 1.5, 2. ])

&gt;&gt;&gt; ts.get_index_at_time(0.9)
2

&gt;&gt;&gt; ts.get_index_at_time(1)
2

&gt;&gt;&gt; ts.get_index_at_time(1.1)
2
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_ts_before_event"><code class="name flex">
<span>def <span class="ident">get_ts_before_event</span></span>(<span>self, event_name, event_occurrence=0, *, inclusive=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a subset of the TimeSeries before the specified event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the event to look for in the events list.</dd>
<dt><strong><code>event_occurrence</code></strong> :&ensp;<code>int</code> (optional)</dt>
<dd>i_th occurence of the event to look for in the events list,
starting at 0. The default is 0.</dd>
<dt><strong><code>inclusive</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to include the given time in the comparison. The default is
False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a></dt>
<dd>A new TimeSeries following the specification.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import ktk
&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.arange(10)/10)
&gt;&gt;&gt; ts.add_event(0.2, 'event')
&gt;&gt;&gt; ts.add_event(0.35, 'event')
&gt;&gt;&gt; ts.time
array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

&gt;&gt;&gt; ts.get_ts_before_event('event').time
array([0. , 0.1])

&gt;&gt;&gt; ts.get_ts_before_event('event', inclusive=True).time
array([0. , 0.1, 0.2])

&gt;&gt;&gt; ts.get_ts_before_event('event', 1).time
array([0. , 0.1, 0.2, 0.3])

&gt;&gt;&gt; ts.get_ts_before_event('event', 1, inclusive=True).time
array([0. , 0.1, 0.2, 0.3, 0.4])
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_ts_before_index"><code class="name flex">
<span>def <span class="ident">get_ts_before_index</span></span>(<span>self, index, *, inclusive=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a subset of the TimeSeries before the specified time index.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>Time index</dd>
<dt><strong><code>inclusive</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to include the given time index. The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a></dt>
<dd>A new TimeSeries following the specification.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import ktk
&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.arange(10)/10)
&gt;&gt;&gt; ts.time
array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

&gt;&gt;&gt; ts.get_ts_before_index(2).time
array([0. , 0.1])

&gt;&gt;&gt; ts.get_ts_before_index(2, inclusive=True).time
array([0. , 0.1, 0.2])
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_ts_before_time"><code class="name flex">
<span>def <span class="ident">get_ts_before_time</span></span>(<span>self, time, *, inclusive=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a subset of the TimeSeries before the specified time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code></dt>
<dd>Time to look for in the TimeSeries' time vector.</dd>
<dt><strong><code>inclusive</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to include the given time in the comparison. The default is
False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a></dt>
<dd>A new TimeSeries following the specification.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import ktk
&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.arange(10)/10)
&gt;&gt;&gt; ts.time
array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

&gt;&gt;&gt; ts.get_ts_before_time(0.3).time
array([0. , 0.1, 0.2])

&gt;&gt;&gt; ts.get_ts_before_time(0.3, inclusive=True).time
array([0. , 0.1, 0.2, 0.3])
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_ts_between_events"><code class="name flex">
<span>def <span class="ident">get_ts_between_events</span></span>(<span>self, event_name1, event_name2, event_occurrence1=0, event_occurrence2=0, *, inclusive=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a subset of the TimeSeries between two specified events.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_name1</code></strong>, <strong><code>event_name2</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the events to look for in the events list.</dd>
<dt><strong><code>event_occurrence1</code></strong>, <strong><code>event_occurrence2</code></strong> :&ensp;<code>int</code> (optional)</dt>
<dd>i_th occurence of the event to look for in the events list,
starting at 0. The default is 0.</dd>
<dt><strong><code>inclusive</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to include the given time in the comparison. The default is
False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a></dt>
<dd>A new TimeSeries following the specification.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import ktk
&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.arange(10)/10)
&gt;&gt;&gt; ts.add_event(0.2, 'event')
&gt;&gt;&gt; ts.add_event(0.55, 'event')
&gt;&gt;&gt; ts.time
array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

&gt;&gt;&gt; ts.get_ts_between_events('event', 'event', 0, 1).time
array([0.3, 0.4, 0.5])

&gt;&gt;&gt; ts.get_ts_between_events('event', 'event', 0, 1,                                          inclusive=True).time
array([0.2, 0.3, 0.4, 0.5, 0.6])
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_ts_between_indexes"><code class="name flex">
<span>def <span class="ident">get_ts_between_indexes</span></span>(<span>self, index1, index2, *, inclusive=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a subset of the TimeSeries before two specified time indexes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>index1</code></strong>, <strong><code>index2</code></strong> :&ensp;<code>int</code></dt>
<dd>Time indexes</dd>
<dt><strong><code>inclusive</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to include the given time index. The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a></dt>
<dd>A new TimeSeries following the specification.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import ktk
&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.arange(10)/10)
&gt;&gt;&gt; ts.time
array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

&gt;&gt;&gt; ts.get_ts_between_indexes(2, 5).time
array([0.3, 0.4])

&gt;&gt;&gt; ts.get_ts_between_indexes(2, 5, inclusive=True).time
array([0.2, 0.3, 0.4, 0.5])
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.get_ts_between_times"><code class="name flex">
<span>def <span class="ident">get_ts_between_times</span></span>(<span>self, time1, time2, *, inclusive=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a subset of the TimeSeries between two specified times.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time1</code></strong>, <strong><code>time2</code></strong> :&ensp;<code>float</code></dt>
<dd>Times to look for in the TimeSeries' time vector.</dd>
<dt><strong><code>inclusive</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to include the given time in the comparison. The default is
False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a></dt>
<dd>A new TimeSeries following the specification.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import ktk
&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.arange(10)/10)
&gt;&gt;&gt; ts.time
array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

&gt;&gt;&gt; ts.get_ts_between_times(0.2, 0.5).time
array([0.3, 0.4])

&gt;&gt;&gt; ts.get_ts_between_times(0.2, 0.5, inclusive=True).time
array([0.2, 0.3, 0.4, 0.5])
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.isnan"><code class="name flex">
<span>def <span class="ident">isnan</span></span>(<span>self, data_key)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a boolean array of missing samples.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_key</code></strong> :&ensp;<code>str</code></dt>
<dd>Key value of the data signal to analyze.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>nans</code></strong> :&ensp;<code>array</code></dt>
<dd>A boolean array of the same size as the time vector, where True
values represent missing samples (samples that contain at least
one nan value).</dd>
</dl></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, ts, data_keys=None, *, resample=False, overwrite=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Merge another TimeSeries into the current TimeSeries.</p>
<p>This function is experimental and may change signature.</p>
<p>This method merges a TimeSeries into the current TimeSeries, copying
the data, data_info and events.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a></dt>
<dd>The TimeSeries to merge into the current TimeSeries.</dd>
<dt><strong><code>data_keys</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code> (optional)</dt>
<dd>The data keys to merge from ts. Default is None, which means that
all the data keys are merged.</dd>
<dt><strong><code>resample</code></strong> :&ensp;<code>bool</code> (optional</dt>
<dd>Set to True to resample the source TimeSeries, in case the time
vectors are not matched. If the time vectors are not matched and
resample is False, an exception is raised. Default is False.</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>If duplicates are found and overwrite is True, then the source (ts)
overwrites the destination. Otherwise (overwrite is False), the
duplicated data is ignored. Default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, data_keys=None, *, event_names=True, legend=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot the TimeSeries using matplotlib.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_keys</code></strong> :&ensp;<code>string</code>, <code>list</code> or <code>tuple</code> (optional)</dt>
<dd>String or list of strings corresponding to the signals to plot.
By default, all elements of the TimeSeries are plotted.</dd>
<dt><strong><code>event_names</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to plot the event names on top of the event lines.
The default is True.</dd>
<dt><strong><code>legend</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to plot a legend, False otherwise. The default is True.</dd>
</dl>
<p>Additional keyboard arguments are passed to the pyplot's plot function.</p>
<h2 id="returns">Returns</h2>
<p>None.</p>
<h2 id="example">Example</h2>
<p>If a TimeSeries <code>ts</code>' data attribute as keys 'Forces', 'Moments' and
'Angle', then:</p>
<pre><code>ts.plot(['Forces', 'Moments'])
</code></pre>
<p>plots only the forces and moments, without plotting the angle.</p></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.remove_data"><code class="name flex">
<span>def <span class="ident">remove_data</span></span>(<span>self, data_key)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove a data key and its associated metadata.</p>
<p>Note: No warning or exception is raised if the data key does not exist.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the data key.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; # Prepare a test TimeSeries with data 'test'
&gt;&gt;&gt; ts = ktk.TimeSeries()
&gt;&gt;&gt; ts.data['test'] = np.arange(10)
&gt;&gt;&gt; ts.add_data_info('test', 'Unit', 'm')

&gt;&gt;&gt; ts.data
{'test': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}

&gt;&gt;&gt; ts.data_info
{'test': {'Unit': 'm'}}

&gt;&gt;&gt; # Now remove data 'test'
&gt;&gt;&gt; ts.remove_data('test')

&gt;&gt;&gt; ts.data
{}

&gt;&gt;&gt; ts.data_info
{}
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.remove_data_info"><code class="name flex">
<span>def <span class="ident">remove_data_info</span></span>(<span>self, data_key, info_key)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove metadata from a TimeSeries' data.</p>
<p>Note: No warning or exception is raised if the data key does not exist.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_key</code></strong> :&ensp;<code>str</code></dt>
<dd>The data key the info corresponds to.</dd>
<dt><strong><code>info_key</code></strong> :&ensp;<code>str</code></dt>
<dd>The key of the info dict.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; ts = ktk.TimeSeries()
&gt;&gt;&gt; ts.add_data_info('Forces', 'Unit', 'N')
&gt;&gt;&gt; ts.data_info['Forces']
{'Unit': 'N'}

&gt;&gt;&gt; ts.remove_data_info('Forces', 'Unit')
&gt;&gt;&gt; ts.data_info['Forces']
{}
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.rename_data"><code class="name flex">
<span>def <span class="ident">rename_data</span></span>(<span>self, old_data_key, new_data_key)</span>
</code></dt>
<dd>
<section class="desc"><p>Rename a key in data and data_info.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>old_data_key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the data key.</dd>
<dt><strong><code>new_data_key</code></strong> :&ensp;<code>str</code></dt>
<dd>New name of the data key.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; ts = ktk.TimeSeries()
&gt;&gt;&gt; ts.data['test'] = np.arange(10)
&gt;&gt;&gt; ts.add_data_info('test', 'Unit', 'm')

&gt;&gt;&gt; ts.data
{'test': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}

&gt;&gt;&gt; ts.data_info
{'test': {'Unit': 'm'}}

&gt;&gt;&gt; ts.rename_data('test', 'signal')

&gt;&gt;&gt; ts.data
{'signal': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}

&gt;&gt;&gt; ts.data_info
{'signal': {'Unit': 'm'}}
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.resample"><code class="name flex">
<span>def <span class="ident">resample</span></span>(<span>self, new_time, kind='linear', *, fill_value=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Resample the TimeSeries.</p>
<p>This function is experimental and may change signature.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>new_time</code></strong> :&ensp;<code>np.array</code></dt>
<dd>The new time vector to resample the TimeSeries to.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>str</code> (optional)</dt>
<dd>The interpolation method. This input may take any value
supported by scipy.interpolate.interp1d, such as:
- 'linear'
- 'nearest'
- 'zero'
- 'slinear'
- 'quadratic'
- 'cubic'
- 'previous'
- 'next'
Additionally, kind can be 'pchip'.</dd>
<dt><strong><code>fill_value</code></strong> :&ensp;<code>array</code>-<code>like</code> or <code>'extrapolate'</code> (optional)</dt>
<dd>The fill value to use if new_time vector contains point outside
the current TimeSeries' time vector. Use 'extrapolate' to
extrapolate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.shift"><code class="name flex">
<span>def <span class="ident">shift</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<section class="desc"><p>Shift time and events.time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time_shift</code></strong> :&ensp;<code>float</code></dt>
<dd>Time to be added to time and events.time.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.sort_events"><code class="name flex">
<span>def <span class="ident">sort_events</span></span>(<span>self, make_unique=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Sorts the TimeSeries' events from the earliest to the latest.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>make_unique</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to make events unique (no two events can have both the same
name and the same time). The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; ts = ktk.TimeSeries(time=np.arange(100)/10)
&gt;&gt;&gt; ts.add_event(2, 'two')
&gt;&gt;&gt; ts.add_event(1, 'one')
&gt;&gt;&gt; ts.add_event(3, 'three')
&gt;&gt;&gt; ts.add_event(3, 'three')

&gt;&gt;&gt; ts.events
[[2.0, 'two'], [1.0, 'one'], [3.0, 'three'], [3.0, 'three']]

&gt;&gt;&gt; ts.sort_events(make_unique=False)
&gt;&gt;&gt; ts.events
[[1.0, 'one'], [2.0, 'two'], [3.0, 'three'], [3.0, 'three']]

&gt;&gt;&gt; ts.sort_events()
&gt;&gt;&gt; ts.events
[[1.0, 'one'], [2.0, 'two'], [3.0, 'three']]
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.sync_event"><code class="name flex">
<span>def <span class="ident">sync_event</span></span>(<span>self, event_name, event_occurrence=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Shift time and events.time so that event_name is the new time zero.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the event to sync on.</dd>
<dt><strong><code>event_occurrence</code></strong> :&ensp;<code>int</code> (optional)</dt>
<dd>Occurrence of the event to sync on. The default is 0, which
corresponds to the first occurrence of the event.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.to_dataframe"><code class="name flex">
<span>def <span class="ident">to_dataframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a DataFrame by reshaping all data to one bidimensional table.</p>
<h2 id="parameters">Parameters</h2>
<p>None.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>DataFrame with the index as the TimeSeries' time. Vector data are
converted to single columns, and 2-dimensional (or more) data are
converted to multiple columns with the additional dimensions in
brackets. The TimeSeries's events and metadata such as time_info
and data_info are not included in the resulting DataFrame.</dd>
</dl></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.trim_events"><code class="name flex">
<span>def <span class="ident">trim_events</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Delete events that are outside the TimeSeries time vector.</p>
<h2 id="parameters">Parameters</h2>
<p>None.</p>
<h2 id="returns">Returns</h2>
<p>None.</p>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import ktk
&gt;&gt;&gt; ts = ktk.TimeSeries(time = np.arange(10))
&gt;&gt;&gt; ts.time
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

&gt;&gt;&gt; ts.add_event(-2)
&gt;&gt;&gt; ts.add_event(0)
&gt;&gt;&gt; ts.add_event(5)
&gt;&gt;&gt; ts.add_event(9)
&gt;&gt;&gt; ts.add_event(10)
&gt;&gt;&gt; ts.events
[[-2.0, 'event'], [0.0, 'event'], [5.0, 'event'], [9.0, 'event'], [10.0, 'event']]

&gt;&gt;&gt; ts.trim_events()
&gt;&gt;&gt; ts.events
[[0.0, 'event'], [5.0, 'event'], [9.0, 'event']]
</code></pre></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.ui_add_event"><code class="name flex">
<span>def <span class="ident">ui_add_event</span></span>(<span>self, name='event', plot=[], multiple_events=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Add one or many events interactively to the TimeSeries.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code> (optional)</dt>
<dd>The name of the event.</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>str</code>, <code>list</code> of <code>str</code> or <code>tuple</code> of <code>str</code> (optional)</dt>
<dd>A signal name of list of signal name to be plotted, similar to
the argument of ktk.TimeSeries.plot().</dd>
<dt><strong><code>multiple_events</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>
<ul>
<li>True to add multiple events with the same name.</li>
<li>False to add only one event (default).</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>boolean</code></dt>
<dd>
<ul>
<li>True if the event was added;</li>
<li>False if the operation was cancelled by the user.</li>
</ul>
</dd>
</dl></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.ui_get_ts_between_clicks"><code class="name flex">
<span>def <span class="ident">ui_get_ts_between_clicks</span></span>(<span>self, data_keys=None, *, inclusive=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a subset of the TimeSeries between two mouse clicks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_keys</code></strong> :&ensp;<code>string</code>, <code>list</code> or <code>tuple</code> (optional)</dt>
<dd>String or list of strings corresponding to the signals to plot.
See TimeSeries.plot() for more information.</dd>
<dt><strong><code>inclusive</code></strong> :&ensp;<code>bool</code> (optional)</dt>
<dd>True to include the given time in the comparison. The default is
False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a></dt>
<dd>A new TimeSeries following the user interaction.</dd>
</dl></section>
</dd>
<dt id="ktk.timeseries.TimeSeries.ui_sync"><code class="name flex">
<span>def <span class="ident">ui_sync</span></span>(<span>self, data_keys=None, ts2=None, data_keys2=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Synchronize one or two TimeSeries by shifting their time.</p>
<p>This function is experimental and may change signature.</p>
<p>If a second TimeSeries is given, both TimeSeries are synchronized and
the sync process is done in three steps:</p>
<ol>
<li>Click on the second TimeSeries's zero-time.</li>
<li>Click on the second TimeSeries on a recognizable event that
is common with the first TimeSeries.</li>
<li>Click on this same event on the first TimeSeries.</li>
</ol>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_keys</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code> (optional)</dt>
<dd>The data keys to plot. The default is None, which means that all
data is plotted.</dd>
<dt><strong><code>ts2</code></strong> :&ensp;<a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a> (optional)</dt>
<dd>A second TimeSeries that contains both a recognizable zero-time
event and a common event with the first TimeSeries.</dd>
<dt><strong><code>data_keys2</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code> (optional)</dt>
<dd>The data keys from the second TimeSeries to plot. The default is
None, which means that all data is plotted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></section>
</dd>
</dl>
</dd>
<dt id="ktk.timeseries.TimeSeriesEvent"><code class="flex name class">
<span>class <span class="ident">TimeSeriesEvent</span></span>
<span>(</span><span>time=0.0, name='event')</span>
</code></dt>
<dd>
<section class="desc"><p>Define an event in a timeseries.</p>
<p>This class derives from the list class. A TimeSeriesEvent is always a
two-items list with the first item being the time and the second item
being the name of the event.</p>
<p>The dependent properties <code>time</code> and <code>name</code> can be used both in read and
write for convenience.</p>
<p>This class is rarely used by itself, it is easier to use the <a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries"><code>TimeSeries</code></a>`
methods to deal with events.</p>
<h2 id="properties">Properties</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code></dt>
<dd>The time at which the event happened.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the event.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; event = ktk.TimeSeriesEvent()
&gt;&gt;&gt; event.time = 1.5
&gt;&gt;&gt; event.name = 'event_name'
&gt;&gt;&gt; event
[1.5, 'event_name']
</code></pre></section>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.list</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ktk.timeseries.TimeSeriesEvent.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="ktk.timeseries.TimeSeriesEvent.time"><code class="name">var <span class="ident">time</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ktk" href="index.html">ktk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ktk.timeseries.dataframe_to_dict_of_arrays" href="#ktk.timeseries.dataframe_to_dict_of_arrays">dataframe_to_dict_of_arrays</a></code></li>
<li><code><a title="ktk.timeseries.dict_of_arrays_to_dataframe" href="#ktk.timeseries.dict_of_arrays_to_dataframe">dict_of_arrays_to_dataframe</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ktk.timeseries.TimeSeries" href="#ktk.timeseries.TimeSeries">TimeSeries</a></code></h4>
<ul class="">
<li><code><a title="ktk.timeseries.TimeSeries.add_data_info" href="#ktk.timeseries.TimeSeries.add_data_info">add_data_info</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.add_event" href="#ktk.timeseries.TimeSeries.add_event">add_event</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.copy" href="#ktk.timeseries.TimeSeries.copy">copy</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.fill_missing_samples" href="#ktk.timeseries.TimeSeries.fill_missing_samples">fill_missing_samples</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.from_dataframe" href="#ktk.timeseries.TimeSeries.from_dataframe">from_dataframe</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_event_time" href="#ktk.timeseries.TimeSeries.get_event_time">get_event_time</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_index_after_time" href="#ktk.timeseries.TimeSeries.get_index_after_time">get_index_after_time</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_index_at_time" href="#ktk.timeseries.TimeSeries.get_index_at_time">get_index_at_time</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_index_before_time" href="#ktk.timeseries.TimeSeries.get_index_before_time">get_index_before_time</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_subset" href="#ktk.timeseries.TimeSeries.get_subset">get_subset</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_ts_after_event" href="#ktk.timeseries.TimeSeries.get_ts_after_event">get_ts_after_event</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_ts_after_index" href="#ktk.timeseries.TimeSeries.get_ts_after_index">get_ts_after_index</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_ts_after_time" href="#ktk.timeseries.TimeSeries.get_ts_after_time">get_ts_after_time</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_ts_at_event" href="#ktk.timeseries.TimeSeries.get_ts_at_event">get_ts_at_event</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_ts_at_time" href="#ktk.timeseries.TimeSeries.get_ts_at_time">get_ts_at_time</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_ts_before_event" href="#ktk.timeseries.TimeSeries.get_ts_before_event">get_ts_before_event</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_ts_before_index" href="#ktk.timeseries.TimeSeries.get_ts_before_index">get_ts_before_index</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_ts_before_time" href="#ktk.timeseries.TimeSeries.get_ts_before_time">get_ts_before_time</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_ts_between_events" href="#ktk.timeseries.TimeSeries.get_ts_between_events">get_ts_between_events</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_ts_between_indexes" href="#ktk.timeseries.TimeSeries.get_ts_between_indexes">get_ts_between_indexes</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.get_ts_between_times" href="#ktk.timeseries.TimeSeries.get_ts_between_times">get_ts_between_times</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.isnan" href="#ktk.timeseries.TimeSeries.isnan">isnan</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.merge" href="#ktk.timeseries.TimeSeries.merge">merge</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.plot" href="#ktk.timeseries.TimeSeries.plot">plot</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.remove_data" href="#ktk.timeseries.TimeSeries.remove_data">remove_data</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.remove_data_info" href="#ktk.timeseries.TimeSeries.remove_data_info">remove_data_info</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.rename_data" href="#ktk.timeseries.TimeSeries.rename_data">rename_data</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.resample" href="#ktk.timeseries.TimeSeries.resample">resample</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.shift" href="#ktk.timeseries.TimeSeries.shift">shift</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.sort_events" href="#ktk.timeseries.TimeSeries.sort_events">sort_events</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.sync_event" href="#ktk.timeseries.TimeSeries.sync_event">sync_event</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.to_dataframe" href="#ktk.timeseries.TimeSeries.to_dataframe">to_dataframe</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.trim_events" href="#ktk.timeseries.TimeSeries.trim_events">trim_events</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.ui_add_event" href="#ktk.timeseries.TimeSeries.ui_add_event">ui_add_event</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.ui_get_ts_between_clicks" href="#ktk.timeseries.TimeSeries.ui_get_ts_between_clicks">ui_get_ts_between_clicks</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeries.ui_sync" href="#ktk.timeseries.TimeSeries.ui_sync">ui_sync</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ktk.timeseries.TimeSeriesEvent" href="#ktk.timeseries.TimeSeriesEvent">TimeSeriesEvent</a></code></h4>
<ul class="">
<li><code><a title="ktk.timeseries.TimeSeriesEvent.name" href="#ktk.timeseries.TimeSeriesEvent.name">name</a></code></li>
<li><code><a title="ktk.timeseries.TimeSeriesEvent.time" href="#ktk.timeseries.TimeSeriesEvent.time">time</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>